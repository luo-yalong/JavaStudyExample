# 秒杀系统

## 秒杀系统

### 秒杀场景

- 电商抢购商品
- 火车票抢座 12306
- ……

### 为什么做个系统

**核心问题**

- 严防商品超卖

### 保护措施有哪些

- 乐观锁防止超卖 --核心--
- 令牌桶限流
- Redis 缓存
- 消息队列一步处理订单

```java
public void main(){
  String abc = "hello";
}
```



## 防止超卖

### 数据库表

```mysql
drop table if exists stock;
create table stock (
	id int(11) unsigned not null auto_increment,
  name varchar(50) not null default '' comment '名称',
  count int(11) not null comment '库存',
  sale int not null comment '已售',
  version int not null comment '乐观锁、版本号',
  primary key(id)
) engine=innodb default charset=utf8;

drop table if exists stock_order;
create table stock_order(
	id int unsigned not null auto_increment,
  sid int not null comment '库存id',
  name varchar(30) not null default '' comment '商品名称',
  create_time timestamp not null default current_timestamp on update current_timestamp comment '创建时间',
  primary key(id)
)engine=innodb default charset=utf8;
```

## 漏斗算法和令牌桶算法

### 令牌桶的使用

> 使用令牌桶

#### 引入依赖

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.0.1-jre</version>
    <scope>compile</scope>
</dependency>
```

#### 使用

限流一般是放在控制器内

```
//创建令牌桶实例
RateLimiter limiter = RateLimiter.create(10);
//代表每秒产生10个令牌

//使用

//没有获取令牌的请求，会一直等待获取令牌
limiter.acquire();

//2. 设置等待时间，如果在等待时间内获取到了令牌，则处理业务。否则，抛弃
limiter.tryAcquire(2,TimeUnit.SECOND);
```

#### 基本使用

1. 阻塞直到获取令牌

```java
//创建实例：每秒种产生20个令牌
private RateLimiter limiter = RateLimiter.create(20);

@GetMapping("/sale")
public String sale(){
    //获取到令牌的请求，执行业务方法，没有获取到令牌的请求，直到获取到令牌，执行业务方法
    log.info("令牌等待时间: " + limiter.acquire());
    //执行业务
    try {
        TimeUnit.MILLISECONDS.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "成功";
}
```

2. 超时抛弃

```java
//创建实例：每秒种产生20个令牌
private RateLimiter limiter = RateLimiter.create(20);

@GetMapping("/sale")
public String sale(){
    //获取到令牌的请求，执行业务方法，没有获取到令牌的请求，直到获取到令牌，执行业务方法
    //log.info("令牌等待时间: " + limiter.acquire());

    //请求在2秒钟内没有获取到令牌，会直接抛弃请求
    if (!limiter.tryAcquire(2, TimeUnit.SECONDS)){
        log.info("抢购失败：服务器进行了限流");
    }

    log.info("执行业务");
    try {
        TimeUnit.MILLISECONDS.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "成功";
}
```

### 改造控制器方法

```java
@GetMapping("/killToken")
public String killToken(Integer id){

    if (!limiter.tryAcquire(3, TimeUnit.SECONDS)){
        log.info("抢购失败：活动太火爆了，请重试！！！");
    }

    System.out.println("秒杀商品的id = " + id);
    //处理秒杀业务逻辑
    try {
        int orderId = orderService.kill(id);
        log.info("秒杀成功：订单ID = " + orderId);
        return "秒杀成功：订单ID = " + orderId;
    } catch (Exception e) {
        //e.printStackTrace();
        log.info("抢购失败：" + e.getMessage());
        return e.getMessage();
    }
}
```

## 完善秒杀接口

​		目前已经完成了防止商品超卖和接口限流，已经能够方法大流量把我们的服务器直接搞炸。我们需要关心一些细节问题。

1. 我们应该在一定时间内执行秒杀处理，不能在任意时间都接受秒杀请求，如果加入时间验证？
2. 对于稍微懂点电脑的人来说，又会动用歪脑筋通过抓包的方式来获取我们的接口地址。然后通过脚本来进行抢购怎么办？
3. 秒杀开始之后如何限制单个用户的请求频率，即单位时间内限制访问次数？

**主要内容**

- 限时抢购
- 抢购接口隐藏
- 单用户限制频率（单位时间内限制访问次数）

### 限时抢购的实现

​		使用`redis`来记录秒杀商品的时间，对秒杀过期的请求进行过期处理

1. 添加依赖

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   ```

    2. 注入 `redisTemplate`

       ```java
       @Resource
       private RedisTemplate<String,Object> redisTemplate;
       
       @Override
       public int kill(Integer id) {
           if (!redisTemplate.hasKey("stock::" + id)){
               throw new RuntimeException("很抱歉，当前秒杀活动已经结束了");
           }
           //校验库存（根据商品id）
           Stock stock = checkStock(id);
           //扣除库存
           reduceStockOfLuckLock(stock);
           //创建订单
           StockOrder order = createOrder(stock);
           return order.getId();
       }
       ```

### 接口隐藏

​		接口已经基本上完成了，但是为了防止某些不法的人，编写一些抢购脚本来直接抢购秒杀脚本。我们需要在请求的时候携带一个 token，用于防止接口被人非法的大量调用

- **创建用户表**

  ```mysql
  CREATE TABLE `user` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户id',
    `name` varchar(50) NOT NULL DEFAULT '' COMMENT '用户姓名',
    `PASSWORD` varchar(50) NOT NULL DEFAULT '' COMMENT '密码',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
  ```

  在用户表中插入一个用户

  ![image-20220113212810620](https://gitee.com/luoyalongLYL/upload_image_repo/raw/master/typroa/2022-01-13/575369d17ce48c15eb652f139d8a5b76.jpeg)

- 编写一个接口，用于获取 token

  ```java
  /**
   * 用户获取md5
   * @param id 商品id
   * @param userid 用户id
   * @return
   */
  @GetMapping("/md5")
  public String getMd5(Integer id,Integer userid){
      //参数校验
      return orderService.getMd5(id,userid);
  }
  ```

​	**service**

```java
@Override
public String getMd5(Integer id, Integer userid) {
    //校验用户
    checkUserWhetherExists(userid);
    //校验商品
    checkStockWhetherExists(id);
    //生成md5，存入redis,同时返回客户端
    //键
    String key = "ms:" + userid + ":" + id;
  	//加盐：#!@$%
    String md5 = SecureUtil.md5((id + userid + "#!@$%"));
    //五分钟内有效
    redisTemplate.opsForValue().set(key,md5,5 * 60 , TimeUnit.SECONDS);
    return "生成的token: " + md5;
}

private void checkUserWhetherExists(Integer userid) {

    User user = userDao.selectById(userid);
    if (user == null) {
        throw new RuntimeException("当前用户不存在");
    }
}

private void checkStockWhetherExists(Integer id) {
    Stock stock = stockDao.selectById(id);
    if (stock == null){
        throw new RuntimeException("当前商品不存在");
    }
}
```

![image-20220113221302972](https://gitee.com/luoyalongLYL/upload_image_repo/raw/master/typroa/2022-01-13/f546cbe1a65742a60d8aab516d02b06e.jpeg)

#### 改造抢购接口

```java
/**
 * 令牌桶限流，接口限时操作以及接口隐藏
 * @param id
 * @param userid
 * @param md5
 * @return
 */
@GetMapping("/killTokenMd5")
public String killTokenMd5(Integer id,Integer userid,String md5){

    if(StrUtil.isBlank(md5)){
        return "请求没有携带签名";
    }

    //令牌桶限流
    if (!limiter.tryAcquire(3, TimeUnit.SECONDS)){
        log.info("抢购失败：活动太火爆了，请重试！！！");
    }

    System.out.println("秒杀商品的id = " + id);
    //处理秒杀业务逻辑
    try {
        int orderId = orderService.killTokenMd5(id,userid,md5);
        log.info("秒杀成功：订单ID = " + orderId);
        return "秒杀成功：订单ID = " + orderId;
    } catch (Exception e) {
        //e.printStackTrace();
        log.info("抢购失败：" + e.getMessage());
        return e.getMessage();
    }
}
```

**service**

```java
@Override
public int killTokenMd5(Integer id, Integer userid, String md5) {
    //接口的限时操作
    if (!redisTemplate.hasKey("stock::" + id)){
        throw new RuntimeException("很抱歉，当前秒杀活动已经结束了");
    }

    //接口防刷-使用md5验证
    String key = "ms:" + userid + ":" + id;
    if (!md5.equals(redisTemplate.opsForValue().get(key))) {
        throw new RuntimeException("当前请求数据不合法");
    }

    //校验库存（根据商品id）
    Stock stock = checkStock(id);
    //扣除库存
    reduceStockOfLuckLock(stock);
    //创建订单
    StockOrder order = createOrder(stock);
    return order.getId();
}
```

### 单用户请求限制

```java
/**
 * 令牌桶限流，接口限时操作以及接口隐藏
 * @param id
 * @param userid
 * @param md5
 * @return
 */
@GetMapping("/killTokenMd5Limit")
public String killTokenMd5Limit(Integer id,Integer userid,String md5){

    if(StrUtil.isBlank(md5)){
        return "请求没有携带签名";
    }

    //令牌桶限流
    if (!limiter.tryAcquire(3, TimeUnit.SECONDS)){
        log.info("抢购失败：活动太火爆了，请重试！！！");
    }

    System.out.println("秒杀商品的id = " + id);
    //处理秒杀业务逻辑
    try {
        //单用户请求限制
        killLimit(id,userid);

        int orderId = orderService.killTokenMd5(id,userid,md5);
        log.info("秒杀成功：订单ID = " + orderId);
        return "秒杀成功：订单ID = " + orderId;
    } catch (Exception e) {
        //e.printStackTrace();
        log.info("抢购失败：" + e.getMessage());
        return e.getMessage();
    }
}

//单用户请求限制
private void killLimit(Integer id,Integer userid){
    String key = "ms:limit:" + id + ":" + userid;
    int n = (int) Optional.ofNullable(redisTemplate.opsForValue().get(key))
            .orElse(0);
    if (n == 0){
        redisTemplate.opsForValue().set(key,1,3600,TimeUnit.SECONDS);
    }else {
        n = n + 1;
        redisTemplate.opsForValue().set(key,n,3600,TimeUnit.SECONDS);
    }
    log.info("当前用户已经请求了: {}次",n);
    if (n > 10){
        throw new RuntimeException("单位时间内达到抢购次数上限");
    }
}
```



![image-20220113225126047](https://gitee.com/luoyalongLYL/upload_image_repo/raw/master/typroa/2022-01-13/cd2a45748e2dee6746a889531e577932.jpeg)

![image-20220113225140842](https://gitee.com/luoyalongLYL/upload_image_repo/raw/master/typroa/2022-01-13/a5ac71a497ecfcedf374fa9e261ee768.jpeg)

![image-20220113225150342](https://gitee.com/luoyalongLYL/upload_image_repo/raw/master/typroa/2022-01-13/7d54deaf9c2a2995fb50d8f545e5dfa6.jpeg)