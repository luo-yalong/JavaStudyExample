# 秒杀系统

## 1. 秒杀系统

### 秒杀场景

- 电商抢购商品
- 火车票抢座 12306
- ……

### 为什么做个系统

**核心问题**

- 严防商品超卖

### 保护措施有哪些

- 乐观锁防止超卖 --核心--
- 令牌桶限流
- Redis 缓存
- 消息队列一步处理订单

```java
public void main(){
  String abc = "hello";
}
```



## 2. 防止超卖

### 数据库表

```mysql
drop table if exists stock;
create table stock (
	id int(11) unsigned not null auto_increment,
  name varchar(50) not null default '' comment '名称',
  count int(11) not null comment '库存',
  sale int not null comment '已售',
  version int not null comment '乐观锁、版本号',
  primary key(id)
) engine=innodb default charset=utf8;

drop table if exists stock_order;
create table stock_order(
	id int unsigned not null auto_increment,
  sid int not null comment '库存id',
  name varchar(30) not null default '' comment '商品名称',
  create_time timestamp not null default current_timestamp on update current_timestamp comment '创建时间',
  primary key(id)
)engine=innodb default charset=utf8;
```

## 3. 悲观锁

> 使用 `synchronized` 同步代码块
>
> **注意**：`synchronized` 和 `Transactional` 作用于同一个方法的时候，需要注意谁在内，谁在外的问题，否则，并发下还是会出现问题

```java
@GetMapping("/kill")
public String kill(Integer id) {
    //System.out.println("秒杀商品的id = " + id);
    //处理秒杀业务逻辑
    try {
        synchronized (this) {
            int orderId = orderService.kill(id);
            log.info("秒杀成功：订单ID = " + orderId);
            return "秒杀成功：订单ID = " + orderId;
        }
    } catch (Exception e) {
        //e.printStackTrace();
        log.error("秒杀:{}", e.getMessage());
        return e.getMessage();
    }
}
```

**Service**

```java
package com.lyl.ms.service.impl;

import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.lyl.ms.dao.StockDao;
import com.lyl.ms.dao.StockOrderDao;
import com.lyl.ms.entity.Stock;
import com.lyl.ms.entity.StockOrder;
import com.lyl.ms.service.OrderService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

@Service
@Transactional(rollbackFor = Exception.class)
public class OrderServiceImpl implements OrderService {
    @Resource
    private StockDao stockDao;
    @Resource
    private StockOrderDao stockOrderDao;

    @Override
    public int kill(Integer id) {
        //校验库存（根据商品id）
        Stock stock = checkStock(id);
        //扣除库存
        reduceStock(stock);
        //创建订单
        StockOrder order = createOrder(stock);
        return order.getId();
    }

    /**
     * 生成订单
     * @param stock
     * @return
     */
    private StockOrder createOrder(Stock stock) {
        StockOrder order = new StockOrder()
                .setSid(stock.getId())
                .setName(stock.getName());
        stockOrderDao.insert(order);
        return order;
    }

    /**
     * 减少库存
     * @param stock
     */
    private void reduceStock(Stock stock) {
        stock.setSale(stock.getSale() + 1);
        stockDao.update(stock,new LambdaUpdateWrapper<Stock>()
                .set(Stock::getSale,stock.getSale())
                .eq(Stock::getId,stock.getId())
        );
    }

    /**
     * 校验库存
     * @param id
     * @return
     */
    private Stock checkStock(Integer id) {
        Stock stock = stockDao.selectById(id);
        if (stock.getSale().equals(stock.getCount())) {
            throw new RuntimeException("库存不足");
        }
        return stock;
    }
}
```



## 4. 乐观锁

使用乐观锁解决超卖问题，实际上就是利用数据库中的 `version`字段和数据库的`事务`来解决并发情况下商品超卖的问题

**controller**

```java
@GetMapping("/kill")
public String kill(Integer id) {
    //处理秒杀业务逻辑
    try {
            int orderId = orderService.kill(id);
            log.info("秒杀成功：订单ID = " + orderId);
            return "秒杀成功：订单ID = " + orderId;
    } catch (Exception e) {
        //e.printStackTrace();
        log.error("秒杀:{}", e.getMessage());
        return e.getMessage();
    }
}
```

**修改扣除库存方法**

```java
/**
 * 乐观锁版本扣除库存
 * @param stock
 */
private void reduceStockOfLuckLock(Stock stock) {
    int affectedRows = stockDao.saleStock(stock);
    if (affectedRows == 0){
        throw new RuntimeException("抢购失败");
    }
}
```

**Serivce方法**

```java
@Override
public int kill(Integer id) {
    //校验库存（根据商品id）
    Stock stock = checkStock(id);

    //扣除库存
    //reduceStock(stock);
    reduceStockOfLuckLock(stock);

    //创建订单
    StockOrder order = createOrder(stock);
    return order.getId();
}
```

**stockDao**

```java
/**
 * 售出商品
 * @param stock 商品
 */
int saleStock(Stock stock);
```

**stockDao.xml**

```xml
<update id="saleStock">
    update stock set sale = sale + 1 , version = version + 1
    where id = #{id} and version = #{version}
</update>
```

### 4.1 完整代码

**Controller**

```java
@GetMapping("/kill")
public String kill(Integer id) {
    //处理秒杀业务逻辑
    try {
            int orderId = orderService.kill(id);
            log.info("秒杀成功：订单ID = " + orderId);
            return "秒杀成功：订单ID = " + orderId;
    } catch (Exception e) {
        //e.printStackTrace();
        log.error("秒杀:{}", e.getMessage());
        return e.getMessage();
    }
}
```

**ServiceImpl**

```java
package com.lyl.ms.service.impl;

import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.lyl.ms.dao.StockDao;
import com.lyl.ms.dao.StockOrderDao;
import com.lyl.ms.entity.Stock;
import com.lyl.ms.entity.StockOrder;
import com.lyl.ms.service.OrderService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

@Service
@Transactional(rollbackFor = Exception.class)
public class OrderServiceImpl implements OrderService {
    @Resource
    private StockDao stockDao;
    @Resource
    private StockOrderDao stockOrderDao;

    @Override
    public int kill(Integer id) {
        //校验库存（根据商品id）
        Stock stock = checkStock(id);

        //扣除库存
        //reduceStock(stock);
        reduceStockOfLuckLock(stock);

        //创建订单
        StockOrder order = createOrder(stock);
        return order.getId();
    }

    /**
     * 生成订单
     * @param stock
     * @return
     */
    private StockOrder createOrder(Stock stock) {
        StockOrder order = new StockOrder()
                .setSid(stock.getId())
                .setName(stock.getName());
        stockOrderDao.insert(order);
        return order;
    }

    /**
     * 减少库存
     * @param stock
     */
    private void reduceStock(Stock stock) {
        stock.setSale(stock.getSale() + 1);
        stockDao.saleStock(stock);
        stockDao.update(stock,new LambdaUpdateWrapper<Stock>()
                .set(Stock::getSale,stock.getSale())
                .eq(Stock::getId,stock.getId())
        );
    }

    /**
     * 乐观锁版本扣除库存
     * @param stock
     */
    private void reduceStockOfLuckLock(Stock stock) {
        //在sql层面完成销量的变化和版本号的增加
        int affectedRows = stockDao.saleStock(stock);
        if (affectedRows == 0){
            throw new RuntimeException("抢购失败");
        }
    }

    /**
     * 校验库存
     * @param id
     * @return
     */
    private Stock checkStock(Integer id) {
        Stock stock = stockDao.selectById(id);
        if (stock.getSale().equals(stock.getCount())) {
            throw new RuntimeException("库存不足");
        }
        return stock;
    }
}
```

**StockDao**

```java
/**
 * 售出商品
 * @param stock 商品
 * @return 影响行数
 */
int saleStock(Stock stock);
```

**StockDao.xml**

```java
<update id="saleStock">
    update stock set sale = sale + 1 , version = version + 1
    where id = #{id} and version = #{version}
</update>
```

## 5. 接口限流

